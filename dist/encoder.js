"use strict";
const visitor_as_1 = require("visitor-as");
const utils_1 = require("visitor-as/dist/utils");
const OR_NULL = /\|.*null/;
function getTypeName(type) {
    let _type = utils_1.getName(type);
    if (type.isNullable && !OR_NULL.test(_type)) {
        _type = `${_type} | null`;
    }
    return _type;
}
class Encoder extends visitor_as_1.ClassDecorator {
    constructor(encoder = "JSON", res_type = "string") {
        super();
        this.encoder = encoder;
        this.res_type = res_type;
    }
    visitFieldDeclaration(node) {
        const name = utils_1.toString(node.name);
        if (!node.type) {
            throw new Error(`Field ${name} is missing a type declaration`);
        }
        const _type = getTypeName(node.type);
        this.encodeStmts.push(`
        encoder.encode_field<${_type}>("${name}", this.${name})
    `);
    }
    visitClassDeclaration(node) {
        if (!node.members || node.members.some(utils_1.isMethodNamed("encode"))) {
            return;
        }
        this.currentClass = node;
        const class_name = utils_1.getName(node);
        this.encodeStmts = [];
        this.decodeStmts = [];
        this.visit(node.members);
        const encodeMethod = `
    encode<__T>(encoder: Encoder<__T>): __T {
      ${node.extendsType != null ? "\n    super.encode<__T>(encoder);" : ""}
      ${this.encodeStmts.join(";\n\t")};
      return encoder.get_encoded_object()
    }
    `;
        const decodeMethod = `
    decode<__T>(decoder: Decoder<__T>): ${class_name} {
      ${this.decodeStmts.join(";\n\t")};${node.extendsType != null ? "\n    super.decode<__T>(decoder);" : ""}
      return decoder.get_decoded_object()
    }
    `;
        let member = visitor_as_1.SimpleParser.parseClassMember(encodeMethod, node);
        node.members.push(member);
    }
    get name() { return "serializable"; }
    visitMethodDeclaration(node) { }
}
module.exports = visitor_as_1.registerDecorator(new Encoder());
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jb2Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9lbmNvZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSwyQ0FBNkU7QUFJN0UsaURBQXlFO0FBRXpFLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQztBQUMzQixTQUFTLFdBQVcsQ0FBQyxJQUFjO0lBQ2pDLElBQUksS0FBSyxHQUFHLGVBQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QixJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQzNDLEtBQUssR0FBRyxHQUFHLEtBQUssU0FBUyxDQUFDO0tBQzNCO0lBQ0gsT0FBTyxLQUFLLENBQUE7QUFDZCxDQUFDO0FBR0QsTUFBTSxPQUFRLFNBQVEsMkJBQWM7SUFLbEMsWUFBbUIsVUFBZSxNQUFNLEVBQ3JCLFdBQWdCLFFBQVE7UUFDekMsS0FBSyxFQUFFLENBQUM7UUFGUyxZQUFPLEdBQVAsT0FBTyxDQUFjO1FBQ3JCLGFBQVEsR0FBUixRQUFRLENBQWdCO0lBRTNDLENBQUM7SUFFRCxxQkFBcUIsQ0FBQyxJQUFzQjtRQUMxQyxNQUFNLElBQUksR0FBRyxnQkFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNkLE1BQU0sSUFBSSxLQUFLLENBQUMsU0FBUyxJQUFJLGdDQUFnQyxDQUFDLENBQUM7U0FDaEU7UUFFRCxNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXJDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDOytCQUNLLEtBQUssTUFBTSxJQUFJLFdBQVcsSUFBSTtLQUN4RCxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQscUJBQXFCLENBQUMsSUFBc0I7UUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMscUJBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFO1lBQy9ELE9BQU87U0FDUjtRQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1FBQ3pCLE1BQU0sVUFBVSxHQUFVLGVBQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUV2QyxJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV6QixNQUFNLFlBQVksR0FBRzs7UUFFakIsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUEsQ0FBQyxDQUFDLG1DQUFtQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ2xFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQzs7O0tBR2pDLENBQUE7UUFDRCxNQUFNLFlBQVksR0FBRzswQ0FDaUIsVUFBVTtRQUM1QyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQSxDQUFDLENBQUMsbUNBQW1DLENBQUMsQ0FBQyxDQUFDLEVBQUU7OztLQUd2RyxDQUFBO1FBQ0QsSUFBSSxNQUFNLEdBQUcseUJBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFL0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVELElBQUksSUFBSSxLQUFhLE9BQU8sY0FBYyxDQUFBLENBQUMsQ0FBQztJQUU1QyxzQkFBc0IsQ0FBQyxJQUF1QixJQUFVLENBQUM7Q0FDMUQ7QUFFRCxpQkFBUyw4QkFBaUIsQ0FBQyxJQUFJLE9BQU8sRUFBRSxDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUeXBlTm9kZSwgQ2xhc3NEZWNsYXJhdGlvbiwgRmllbGREZWNsYXJhdGlvbiwgTWV0aG9kRGVjbGFyYXRpb24gfSBmcm9tIFwidmlzaXRvci1hcy9hc1wiO1xuaW1wb3J0IHsgU2ltcGxlUGFyc2VyLCBDbGFzc0RlY29yYXRvciwgcmVnaXN0ZXJEZWNvcmF0b3IgfSBmcm9tIFwidmlzaXRvci1hc1wiO1xuXG5cblxuaW1wb3J0IHsgdG9TdHJpbmcsIGlzTWV0aG9kTmFtZWQsIGdldE5hbWUgfSBmcm9tICd2aXNpdG9yLWFzL2Rpc3QvdXRpbHMnO1xuXG5jb25zdCBPUl9OVUxMID0gL1xcfC4qbnVsbC87XG5mdW5jdGlvbiBnZXRUeXBlTmFtZSh0eXBlOiBUeXBlTm9kZSk6IHN0cmluZyB7IFxuICBsZXQgX3R5cGUgPSBnZXROYW1lKHR5cGUpO1xuICAgIGlmICh0eXBlLmlzTnVsbGFibGUgJiYgIU9SX05VTEwudGVzdChfdHlwZSkpIHsgXG4gICAgICBfdHlwZSA9IGAke190eXBlfSB8IG51bGxgO1xuICAgIH1cbiAgcmV0dXJuIF90eXBlXG59XG5cblxuY2xhc3MgRW5jb2RlciBleHRlbmRzIENsYXNzRGVjb3JhdG9yIHtcbiAgY3VycmVudENsYXNzPzogQ2xhc3NEZWNsYXJhdGlvbjtcbiAgZW5jb2RlU3RtdHM6IHN0cmluZ1tdO1xuICBkZWNvZGVTdG10czogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IocHVibGljIGVuY29kZXI6c3RyaW5nPVwiSlNPTlwiLFxuICAgICAgICAgICAgICBwdWJsaWMgcmVzX3R5cGU6c3RyaW5nPVwic3RyaW5nXCIpe1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICB2aXNpdEZpZWxkRGVjbGFyYXRpb24obm9kZTogRmllbGREZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIGNvbnN0IG5hbWUgPSB0b1N0cmluZyhub2RlLm5hbWUpO1xuICAgIGlmICghbm9kZS50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkICR7bmFtZX0gaXMgbWlzc2luZyBhIHR5cGUgZGVjbGFyYXRpb25gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgX3R5cGUgPSBnZXRUeXBlTmFtZShub2RlLnR5cGUpO1xuICAgIFxuICAgIHRoaXMuZW5jb2RlU3RtdHMucHVzaChgXG4gICAgICAgIGVuY29kZXIuZW5jb2RlX2ZpZWxkPCR7X3R5cGV9PihcIiR7bmFtZX1cIiwgdGhpcy4ke25hbWV9KVxuICAgIGApO1xuICB9XG5cbiAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uKG5vZGU6IENsYXNzRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAoIW5vZGUubWVtYmVycyB8fCBub2RlLm1lbWJlcnMuc29tZShpc01ldGhvZE5hbWVkKFwiZW5jb2RlXCIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmN1cnJlbnRDbGFzcyA9IG5vZGU7XG4gICAgY29uc3QgY2xhc3NfbmFtZTpzdHJpbmcgPSBnZXROYW1lKG5vZGUpXG5cbiAgICB0aGlzLmVuY29kZVN0bXRzID0gW107XG4gICAgdGhpcy5kZWNvZGVTdG10cyA9IFtdO1xuICAgIHRoaXMudmlzaXQobm9kZS5tZW1iZXJzKTtcblxuICAgIGNvbnN0IGVuY29kZU1ldGhvZCA9IGBcbiAgICBlbmNvZGU8X19UPihlbmNvZGVyOiBFbmNvZGVyPF9fVD4pOiBfX1Qge1xuICAgICAgJHtub2RlLmV4dGVuZHNUeXBlICE9IG51bGw/IFwiXFxuICAgIHN1cGVyLmVuY29kZTxfX1Q+KGVuY29kZXIpO1wiIDogXCJcIn1cbiAgICAgICR7dGhpcy5lbmNvZGVTdG10cy5qb2luKFwiO1xcblxcdFwiKX07XG4gICAgICByZXR1cm4gZW5jb2Rlci5nZXRfZW5jb2RlZF9vYmplY3QoKVxuICAgIH1cbiAgICBgXG4gICAgY29uc3QgZGVjb2RlTWV0aG9kID0gYFxuICAgIGRlY29kZTxfX1Q+KGRlY29kZXI6IERlY29kZXI8X19UPik6ICR7Y2xhc3NfbmFtZX0ge1xuICAgICAgJHt0aGlzLmRlY29kZVN0bXRzLmpvaW4oXCI7XFxuXFx0XCIpfTske25vZGUuZXh0ZW5kc1R5cGUgIT0gbnVsbD8gXCJcXG4gICAgc3VwZXIuZGVjb2RlPF9fVD4oZGVjb2Rlcik7XCIgOiBcIlwifVxuICAgICAgcmV0dXJuIGRlY29kZXIuZ2V0X2RlY29kZWRfb2JqZWN0KClcbiAgICB9XG4gICAgYFxuICAgIGxldCBtZW1iZXIgPSBTaW1wbGVQYXJzZXIucGFyc2VDbGFzc01lbWJlcihlbmNvZGVNZXRob2QsIG5vZGUpO1xuXG4gICAgbm9kZS5tZW1iZXJzLnB1c2gobWVtYmVyKTtcbiAgfVxuXG4gIGdldCBuYW1lKCk6IHN0cmluZyB7IHJldHVybiBcInNlcmlhbGl6YWJsZVwiIH1cbiBcbiAgdmlzaXRNZXRob2REZWNsYXJhdGlvbihub2RlOiBNZXRob2REZWNsYXJhdGlvbik6IHZvaWQgeyB9XG59XG5cbmV4cG9ydCA9IHJlZ2lzdGVyRGVjb3JhdG9yKG5ldyBFbmNvZGVyKCkpIl19